

### **ДИВІТЬСЯ КОД TEST_LAB.py**

---

**Рішення: Вимога 1**

1. **Окремий облік занять для кожної підгрупи:**

   Я модифікував метод `_calculate_soft_constraints` класу `Schedule`, щоб він обчислював кількість запланованих занять окремо для кожної підгрупи.

   ```python
   def _calculate_soft_constraints(self):
       penalty = 0
       for subject in subjects:
           group = next((g for g in groups if g.number == subject.group_id), None)
           if not group:
               continue
           subgroups = group.subgroups if group.subgroups else [None]
           for subgroup in subgroups:
               scheduled_lectures = 0
               scheduled_practicals = 0
               required_lectures = subject.num_lectures // len(subgroups) if subject.requires_subgroups else subject.num_lectures
               required_practicals = subject.num_practicals // len(subgroups) if subject.requires_subgroups else subject.num_practicals
               for timetable in [self.even_timetable, self.odd_timetable]:
                   for time_slot, lessons in timetable.items():
                       for lesson in lessons:
                           if (lesson.subject.id == subject.id and
                               lesson.group.number == group.number and
                               lesson.subgroup == subgroup):
                               if lesson.type == 'Лекція':
                                   scheduled_lectures += 1
                               elif lesson.type == 'Практика':
                                   scheduled_practicals += 1
               diff_lectures = scheduled_lectures - required_lectures
               diff_practicals = scheduled_practicals - required_practicals
               penalty += abs(diff_lectures) * 2
               penalty += abs(diff_practicals) * 2
       return penalty
   ```

   **Пояснення:**

   - **Облік підгруп:** Для кожного предмета і групи я отримую список підгруп. Якщо підгруп немає, використовую `[None]`, щоб обробити групи без підгруп.
   - **Розрахунок запланованих занять:** Для кожної підгрупи окремо обчислюю кількість запланованих лекцій та практичних занять, перебираючи всі уроки в розкладі.
   - **Розрахунок необхідних занять:** Обчислюю необхідну кількість занять для кожної підгрупи, ділячи загальну кількість занять на кількість підгруп (для предметів, які вимагають підгруп).
   - **Обчислення штрафів:** Розраховую різницю між запланованими та необхідними заняттями для кожної підгрупи. Штраф додається пропорційно до абсолютного значення цієї різниці.
   - **Результат:** Таким чином, фітнес-функція враховує дисбаланс у кількості занять між підгрупами, і ідеальний скор можливий лише тоді, коли всі підгрупи мають необхідну кількість занять.

2. **Перевірка під час створення розкладу:**

   У функції `create_initial_population` під час створення початкового розкладу я переконався, що заняття призначаються для кожної підгрупи окремо.

   ```python
   # Практичні
   pract_total = subject.num_practicals
   if subject.requires_subgroups and group.subgroups:
       num_practicals_per_subgroup = pract_total // len(group.subgroups)
       for subgroup in group.subgroups:
           for _ in range(num_practicals_per_subgroup):
               lesson = Lesson(subject, 'Практика', group, subgroup)
               # Далі призначення викладача, аудиторії та часового слоту
   ```

   **Пояснення:**

   - **Рівномірний розподіл занять:** Загальну кількість практичних занять ділю на кількість підгруп, щоб кожна підгрупа отримала рівну кількість занять.
   - **Створення занять для кожної підгрупи:** Для кожної підгрупи створюються відповідні заняття, які потім призначаються викладачам, аудиторіям і часовим слотам.
   - **Результат:** Це забезпечує, що під час ініціалізації розкладу кожна підгрупа має належну кількість занять.

---

### **Вимога 2**


1. **Розширення функції мутації:**

   У функції `mutate` я додав можливість випадкового додавання та видалення занять з розкладу.

   ```python
   def mutate(schedule):
       mutation_rate = 0.1  # Ймовірність мутації 10%
       for timetable in [schedule.even_timetable, schedule.odd_timetable]:
           # Шанс додати нове заняття
           if random.random() < mutation_rate:
               add_random_lesson(timetable)
           # Шанс видалити існуюче заняття
           if random.random() < mutation_rate:
               remove_random_lesson(timetable)
           # Подальша мутація шляхом зміни часового слоту занять
   ```

   **Пояснення:**

   - **Додавання та видалення занять:** Додаються функції `add_random_lesson` та `remove_random_lesson`, які відповідають за додавання та видалення занять.
   - **Ймовірність мутації:** Використовується параметр `mutation_rate`, який визначає ймовірність додавання або видалення заняття.
   - **Результат:** Це допомагає компенсувати втрату занять під час кросоверу, оскільки мутація може додати втрачені заняття назад у розклад.

2. **Додавання заняття з урахуванням підгруп:**

   Функція `add_random_lesson` додає заняття для всіх підгруп одночасно, якщо предмет вимагає підгруп.

   ```python
   def add_random_lesson(timetable):
       # Випадковий предмет та тип заняття
       # ...
       lessons_to_add = []
       if lesson_type == 'Практика' and subject.requires_subgroups and group.subgroups:
           for subgroup in group.subgroups:
               lesson = Lesson(subject, lesson_type, group, subgroup)
               lessons_to_add.append(lesson)
       else:
           lesson = Lesson(subject, lesson_type, group)
           lessons_to_add.append(lesson)
       # Призначаємо викладача та аудиторію для кожного заняття
       # ...
       # Призначаємо часовий слот без конфліктів
       # ...
   ```

   **Пояснення:**

   - **Створення списку занять:** Якщо предмет вимагає підгруп, створюємо заняття для кожної підгрупи та додаємо їх до списку `lessons_to_add`.
   - **Призначення викладача та аудиторії:** Для кожного заняття з цього списку призначаємо викладача та аудиторію, перевіряючи жорсткі обмеження.
   - **Призначення часового слоту:** Перебираємо часові слоти та перевіряємо, чи можна призначити всі заняття з `lessons_to_add` без конфліктів. Якщо так, додаємо їх до розкладу.
   - **Результат:** Це гарантує, що при додаванні заняття для предмета з підгрупами, заняття додаються для всіх підгруп одночасно, зберігаючи баланс.

3. **Видалення заняття з урахуванням підгруп:**

   Функція `remove_random_lesson` видаляє всі пов'язані заняття для підгруп одночасно.

   ```python
   def remove_random_lesson(timetable):
       # Випадкове заняття для видалення
       # ...
       lessons_to_remove = []
       if lesson_to_remove.subgroup:
           for lessons in timetable.values():
               for lesson in lessons:
                   if (lesson.subject.id == lesson_to_remove.subject.id and
                       lesson.group.number == lesson_to_remove.group.number and
                       lesson.type == lesson_to_remove.type):
                       lessons_to_remove.append(lesson)
       else:
           lessons_to_remove.append(lesson_to_remove)
       for lesson in lessons_to_remove:
           timetable[lesson.time_slot].remove(lesson)
   ```

   **Пояснення:**

   - **Визначення занять для видалення:** Якщо заняття належить до підгрупи, шукаємо всі заняття з тим самим предметом, групою та типом, незалежно від підгрупи.
   - **Видалення занять:** Видаляємо всі знайдені заняття з розкладу.
   - **Результат:** Це забезпечує, що заняття видаляються одночасно для всіх підгруп, зберігаючи баланс і коректність розкладу.

4. **Перевірка конфліктів з урахуванням підгруп:**

   Функція `is_conflict` перевіряє конфлікти між заняттями з урахуванням підгруп.

   ```python
   def is_conflict(lesson, time_slot, timetable):
       for existing_lesson in timetable[time_slot]:
           # Перевірка викладача
           # ...
           # Перевірка аудиторії
           # ...
           # Перевірка групи та підгрупи
           if lesson.group.number == existing_lesson.group.number:
               if lesson.subgroup == existing_lesson.subgroup:
                   return True
               # Якщо одне з занять без підгрупи
               if not lesson.subgroup or not existing_lesson.subgroup:
                   return True
       return False
   ```

   **Пояснення:**

   - **Конфлікт по підгрупах:** Якщо заняття належать до однієї групи та тієї ж підгрупи, це конфлікт.
   - **Конфлікт з заняттям без підгрупи:** Якщо одне з занять не має підгрупи (наприклад, лекція), воно конфліктує з будь-яким заняттям підгрупи тієї ж групи.
   - **Результат:** Ця перевірка гарантує, що заняття не накладаються одне на одне, враховуючи підгрупи.

---

.












## Звіт по Вимогам для Програми Генерації Розкладу `schedule_generator.py`

### **1. Список Груп та Підгруп**
**Вимога:** 
- Список груп \( G \), у кожної з яких є \( N \) студентів. 
- Поділ на підгрупи приблизно навпіл, який не змінюється протягом навчання.

**Реалізація:**
- **CSV-Файл `groups.csv`:** Містить інформацію про групи, кількість студентів та підгрупи.
- **Клас `Group`:** Відповідає за зберігання даних про групи та їхні підгрупи.
- **Генерація Підгруп:** Якщо предмет вимагає поділу на підгрупи (`requires_subgroups = 'Yes'`), група ділиться на підгрупи рівною кількістю студентів.

### **2. Перелік Предметів для Кожної Групи**
**Вимога:** 
- Для кожної групи перелік предметів \( P_i \) з визначеною кількістю годин \( T \) для семестру, включаючи лекції та практичні/лабораторні.

**Реалізація:**
- **CSV-Файл `subjects.csv`:** Містить інформацію про предмети, групи, кількість лекцій та практичних, вимогу поділу на підгрупи та тип тижня (`weekType`).
- **Клас `Subject`:** Зберігає деталі кожного предмету.
- **Генерація Занять:** Для кожного предмету створюються відповідні заняття (лекції та практичні) з урахуванням кількості годин.

### **3. Список Лекторів з Обмеженнями**
**Вимога:** 
- Список лекторів \( L \) з інформацією про предмети та типи занять, які вони можуть проводити.

**Реалізація:**
- **CSV-Файл `lecturers.csv`:** Містить інформацію про лекторів, предмети, які вони можуть викладати (`subjectsCanTeach`), типи занять (`typesCanTeach`) та максимальну кількість годин на тиждень.
- **Клас `Lecturer`:** Зберігає дані про лекторів та їхні обмеження.
- **Призначення Викладачів:** При створенні заняття випадковим чином обирається викладач з відповідними дозволеними предметами та типами занять.

### **4. Список Аудиторій з Ємністю**
**Вимога:** 
- Список аудиторій \( A \) з інформацією про їхню місткість \( m \).

**Реалізація:**
- **CSV-Файл `auditoriums.csv`:** Містить інформацію про аудиторії та їхню місткість.
- **Клас `Auditorium`:** Зберігає дані про аудиторії.
- **Призначення Аудиторій:** Для кожного заняття випадковим чином обирається аудиторія, яка відповідає вимогам щодо місткості.

### **5. Обмеження на Кількість Пар**
**Вимога:** 
- Максимум 20 пар на тиждень (4 пари на день).

**Реалізація:**
- **Часові Слоти:** Визначені як 5 днів на тиждень по 4 періоди (пари) на день.
- **Обмеження:** Генетичний алгоритм враховує лише доступні часові слоти, забезпечуючи, що не більше 4 пар призначено на день для кожної групи та викладача.

### **6. Випадкова Генерація Даних**
**Вимога:** 
- Дані повинні бути легко змінювані через файли, без потреби змінювати код.

**Реалізація:**
- **CSV-Файли:** Всі основні дані (групи, предмети, лектори, аудиторії) зберігаються у CSV-файлах, що дозволяє легко змінювати параметри без редагування коду.
- **Генерація Розкладу:** Алгоритм використовує дані з CSV-файлів для створення розкладу, що забезпечує гнучкість та масштабованість.

### **7. Читабельний Вивід Розкладу**
**Вимога:** 
- Читабельний вивід розкладу в консолі.

**Реалізація:**
- **Бібліотека `tabulate`:** Використовується для форматованого виводу розкладу у вигляді таблиць.
- **Функція `print_schedule`:** Відображає розклад окремо для парного та непарного тижня з детальною інформацією про кожне заняття.

### **8. Умови Викладачів та Аудиторій**
**Вимога:** 
- Один лектор може проводити лише одне заняття одночасно.
- Одна аудиторія може використовуватися одночасно лише під одне заняття, з винятком лекцій, де в аудиторії може бути декілька груп.

**Реалізація:**
- **Перевірка Подвійних Бронювань:** У фітнес-функції перевіряється, щоб лектори та аудиторії не бронювались одночасно для декількох занять.
- **Лекції:** Дозволяється декілька груп одночасно в аудиторії лише для лекцій, що враховано в логіці призначення аудиторій.

### **9. Стабільність Підгруп**
**Вимога:** 
- Підгрупи не змінюють склад протягом навчання.

**Реалізація:**
- **Ініціалізація Підгруп:** Підгрупи створюються при завантаженні даних і залишаються сталими протягом усього процесу генерації розкладу.
- **Клас `Group`:** Зберігає інформацію про підгрупи, яка не змінюється після ініціалізації.

### **10. Стабільність Розміру Популяції**
**Вимога:** 
- Генетичний алгоритм забезпечує стабільний розмір популяції.

**Реалізація:**
- **Параметри Алгоритму:** Розмір популяції встановлено на 100, а кількість поколінь на 200.
- **Створення та Оновлення Популяції:** Після кожного покоління створюється нова популяція точно такого ж розміру, забезпечуючи стабільність.

---

